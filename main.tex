\documentclass[conference,compsoc]{sty/IEEEtran}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{dirtytalk}

% *** CITATION PACKAGES ***
%
\ifCLASSOPTIONcompsoc
  \usepackage[nocompress]{cite}
\else
  \usepackage{cite}
\fi



% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}

\usepackage{minted}
\usepackage{array}
\usepackage[tablename=Tabla]{caption}



\begin{document}

\title{Artículo \\ MongoDB}


\author{\IEEEauthorblockN{Kenneth Calvo, Johan Durán, Esteban Quirós, Elzbieta Malinowski} 
\IEEEauthorblockA{ 
Facultad de Ciencias de la Computación e Informática\\
Universidad de Costa Rica, San Pedro\\
San José, Costa Rica\\
\{keneth.calvo, johan.durancerdas, esteban.quirosaguilar, elzbieta.malinowski\}@ucr.ac.cr
}
}


%\author{\IEEEauthorblockN{Kenneth Calvo}
%\IEEEauthorblockA{Ciencias de la\\Computación e Informática\\
%Universidad de Costa Rica\\
%Montes de Oca, San José 8631--3367\\
%Email: keneth.calvo@ucr.ac.cr}
%\and
%\IEEEauthorblockN{Johan Durán}
%\IEEEauthorblockA{Ciencias de la\\Computación e Informática\\
%Universidad de Costa Rica\\
%Montes de Oca, San José 8966--9038\\
%Email: johan.durancerdas@ucr.ac.cr}
%\and
%\IEEEauthorblockN{Esteban Quirós}
%\IEEEauthorblockA{Ciencias de la\\Computación e Informática\\
%Universidad de Costa Rica\\
%Montes de Oca, San José 8304--5047\\
%Email: esteban.quirosaguilar@ucr.ac.cr}}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
The abstract goes here.
\end{abstract}

% no keywords

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}
Gran parte de los datos producidos por redes sociales, IoT (Internet of Things), transacciones, entre otros, crece diariamente de manera significativa. Los sistemas relacionales usados comúnmente para almacenar y manipular dichos datos empezaron a demostrar limitaciones; esto motivó a empresas como Google, Facebook, Amazon, entre otras entidades, a la búsqueda de nuevas tecnologías para solventar esos problemas. Dichas investigaciones dieron como resultado en lo que actualmente se conoce como NoSQL (Not only SQL o No SQL). Algunos ejemplos de bases de datos NoSQL son: Hbase \cite{Hbase} y Cassandra \cite{Cassandra} de Apache, Bigtable \cite{Bigtable} de Google y MongoDB \cite{MongoInAction} de MongoDB, Inc. 

MongoDB es un software que permite a los usuarios trabajar con bases de datos presentados en forma de así llamados documentos, los cuales son almacenados en un formato llamado BSON (Binary JSON). Además permite el trabajo sobre los datos sin necesidad de tener un esquema previamente definido al contrario de bases relacionales donde hay que definir un esquema con el cual trabajar. No definir un esquema le permite a los diseñadores o programadores un trabajo mas ágil en términos de flexibilidad y libertad al crear bases de datos. Además, ofrece una base de datos adaptable a cambios en la estructura y cantidad de datos sin la necesidad de un esfuerzo de trabajo elevado, al contrario de como se realiza actualmente con bases de datos con esquema \cite{esquema}.

MongoDB es uno de los sistemas de bases de datos más conocidos y debido a esto en muchas ocasiones es contrastado con sistemas relacionales \cite{CRUDMongoMySQL, MongoDBvsOracle} y no relacionales \cite{MongovsCassandravsCouch,NoSQLDatabases}. Sin embargo, esta investigación no ha encontrado evidencia de comparación en el desempeño de consultas entre los diferentes métodos que ofrece MongoDB, por ejemplo: uso de documentos anidados o referenciados, índice, operador lookup. Y es por esto que en el presente artículo se muestra una comparación entre el desempeño de los documentos anidados, método promovido inicialmente por MongoDB para el manejo de datos, y del operador Lookup, solución implementada posteriormente para contrarrestar la necesidad de realizar join. 

%.de manera flexible, escalable y de fácil implementación sin poner en riesgo la eficacia de las consultas \cite{Chodorow}.
%lookup, que fue implementado para contrarrestar la necesidad de realizar join entre colecciones  

Este artículo está organizado de la siguiente manera. En la sección 2 se presentan los trabajos relacionados con el tema. En la sección 3 se muestra la estructura de MongoDB, incluyendo el modelaje de datos para casos de estudio y consultas. En la sección 4 se analiza el desempeño de las consultas en los diferentes casos de prueba. Por último, en la sección 5 se presenta las conclusiones de este artículo.  


\section{Trabajos relacionados}
Existen múltiples trabajos que realizan una comparación de las operaciones CRUD (Create, Read, Update y Delete) y de otras funcionalidades básicas de diferentes sistemas de bases de datos relacionales como MySQL\cite{CRUDMongoMySQL} y Oracle\cite{MongoDBvsOracle} con sus equivalentes en MongoDB. Con respecto a MongoDB se destaca la facilidad de uso, simplicidad y esquema definido con las instancias como factores que podrían promover el uso de MongoDB con respecto a las bases de datos relacionales anteriormente mencionadas.

Además, existen trabajos que comparan MongoDB con otras bases de datos NoSQL \cite{MongovsCassandravsCouch,NoSQLDatabases,TypesNoSQLDBs}. Esta comparación permite entender características de diferentes modelos de datos usados en esas bases NoSQL y  presentar opciones de selección de modelo adecuado de acuerdo a los diferentes casos de estudio.% Esto con el propósito de caracterizar los diferentes modelos de datos y dar una idea de cuales opciones de sistemas de bases de datos NoSQL pueden ser aplicables en los diferentes casos de uso.

Otros trabajos se refieren a diferentes aspectos del propio MongoDB, por ejemplo, sobre patrones de diseño \cite{patronDiseno}, modelado y consultas \cite{AroraAggarwal,VeraBoa}, mejoramientos del algoritmo de auto sharding \cite{auto_sharding}, estructura de documentos anidados \cite{embedding}.

\section{Representación de datos en MongoDB}

%En esta sección se presenta la base de datos que se va a utilizar para el desarrollo del artículo, además de la limpieza y organización que se le hicieron a los mismos.

\subsection{Estructura de MongoDB}

MongoDB es una base de datos cuyo modelo representa por medio documentos. Un documento debe de tener una llave primaria \say{\_id} que lo distinga de los demás, la cual puede ser de cualquier tipo, sin embargo, por defecto es \say{ObjectId}. El ObjectID es un objeto de 12 bytes compuesto por 4 bytes que representan el tiempo en segundos en que fue insertado, 3 bytes que identifica a la maquina, 2 bytes que representa al proceso que lo insertó y los últimos 3 bytes que representa un contador \cite{ObjectId}. 

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2, breaklines]{json}
               
{
	"_id" : "58a78d740b0fa18b936f1d9a",
	"movieId" : 1,
	"title" : "Toy Story (1995)",
	"genres" : "Adventure|Animation| Children|Comedy|Fantasy"
}

\end{minted}
\caption{Representación de documentos en MongoDB} 
\label{fig:documento-mongo}
\end{figure}

La representación de un documento, el cual se puede apreciar en la figura \ref{fig:documento-mongo}, es descrita por un conjunto de pares atributo - valor, donde primero se encuentra el atributo \say{\_id} descrito anteriormente y luego se encuentran los demás valores que complementan al documento. Para ingresar un documento a la base de datos se debe tomar las siguientes consideraciones: dos documentos no pueden contener la misma llave primaria, el orden de las llaves importan, esto quiere decir que dos documentos que contienen las mismas llaves en distinto orden son considerados como documentos diferentes, se hace distinción entre las letras mayúsculas y minúsculas, entre otros \cite{Chodorow}.






%puede ser descrito como un conjunto ordenados de pares llave-valor representados de la siguiente forma.

 %   \{ \say{Llave1} : Valor1, \say{Llave2} : Valor2 \}
    
% intentar subir la explcación del _id y poner la figura de peli, antes de la parte atributo valor

%En el cual debe de tener una llave primaria \say{\_id} que lo distinga de los demás, la cual puede ser de cualquier tipo, sin embargo, por defecto es \say{ObjectId}, el cual es un objeto de 12 bytes compuesto por 4 bytes que representan el tiempo en segundos en que fue insertado, 3 bytes que identifica a la maquina, 2 bytes que representa al proceso que lo insertó y los últimos 3 bytes para un contador \cite{ObjectId}. Además se debe de considerar los siguientes factores para crear un documento. El primero y mas importante, dos documentos no pueden contener la misma llave primaria. El orden de las llaves importan, esto quiere decir que dos documentos que contienen las mismas llaves en distinto orden son considerados como documentos diferentes. Se hace distinción entre las letras mayúsculas y minúsculas, entre otros \cite{Chodorow}.

Los valores asociados a las llaves en un documento puede ser de varios tipos como: hileras, números, arreglos e incluso se puede contener un documento, lo que se le conoce como documentos anidados.  Esto representa una ventaja en en el modelado de datos, ya que si se usara el modelo de bases de datos relacionales primero habría que pasar por un proceso de normalización el cual ocasionaría la creación de más tablas y separar datos que podrían considerarse como unidos \cite{Chodorow}.

Los documentos son almacenados en una colección. Una colección es similar a una tabla en bases de datos relacionales y su función es almacenar datos que tengan un fin en común. Las colecciones en Mongo pueden ser de diferentes formas, esto significa que, un documento con un valor de tipo booleano y otro documento con un valor de tipo entero pueden estar almacenados en la misma colección, lo que le da bastante libertad a los diseñadores de bases de datos para crear la estructura de la misma \cite{Chodorow}.

Para realizar consultas que sean mas eficientes Mongo provee el uso de índices el cual ayuda a limitar la búsqueda para cierto valor. Sin definir un índice, se tendría que hacer una búsqueda exhaustiva por toda la colección para encontrar los datos que cumplen la condición dada. Por defecto Mongo indexa sobre el campo \say{\_id} pero se pueden definir sobre otra llave para mejorar las búsquedas más frecuentes \cite{indiceMongo}.\par 
%que puede ser simplemente un cursor o una nueva colección

La tubería de agregación (aggregation pipeline) ofrecida por MongoDB es un marco de referencia que permite a un documento de entrada pasar por una serie de etapas para generar una colección o retornar un cursor. Un cursor es un puntero al conjunto de resultados de la consulta\cite{aggregationMongo}. Las etapas indican distintas operaciones ejecutadas por Mongo, por ejemplo: 
%\textbf{/*En caso de conservarse la sección de doble lookup, descomentar las siguientes líneas donde se deben explicar los operadores utilizados*/}\par
 \begin{itemize}
     \item match: Seleccionar los documentos que cumplen con un criterio de búsqueda.%, por ejemplo, considerar solamente documentos con identificador menor a 100.
     \item project: Modificar la estructura del documento. %Por ejemplo decidir cuales campos mostrar o no, a cuales darle un nuevo nombre o un nuevo valor. 
     \item lookup: Ejecutar un left outer join.   
     \item unwind: Dado un documento con un arreglo dentro, se separa y crear un nuevo documento para cada entrada del arreglo. 
     \item group: Agrupar los documentos por un campo llave, se puede realizar operaciones de grupos sobre dichos resultados, algunas de la operaciones de grupos son:
     \begin{itemize}
         \item push: Insertar un campo de los elementos del grupo en un arreglo.
         \item first: Tomar el primer elemento del grupo.
     \end{itemize}
     \item out: Especificar punto de almacenamiento de los resultados.
 \end{itemize}
La operación lookup es parte de las funciones de agregación de mongo. Esta operación simula un left outer join de la colección que llama a la función y la colección que se referencia dentro, que corresponde al campo from en la función. Este join se realiza con respecto a un campo de las dos colecciones con las que se realizará el join, los campos son llamados localField y foreignField.  El resultado es un documento casi idéntico al que se tenía anteriormente con la diferencia de que contiene un nuevo campo en forma de arreglo que contiene los campos de cada documento relacionado. La forma básica del lookup se puede apreciar en la figura \ref{fig:consulta-basica-lookup} \cite{lookupMongo}.

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{js}
db.Coleccion1.aggregate([
  {$lookup:
    {from: "Coleccion2",
    localField: "campo_Coleccion1",
    foreignField: "campo_Coleccion2",
    as: "nombre_del_resultado"}
  }
])
\end{minted}
\caption{Consulta basica lookup} 
\label{fig:consulta-basica-lookup}
\end{figure}

%\subsection{Limites de la tubería de agregación}
%Unir con la idea de la tubería.
%Mejorar redacción.
%se crean doc inter que no supere cierto limite
%Y por otra parte la tubería no puede sobrepasar esto.
%No hablar de cursor

A pesar de que la tubería de agregación permite realizar distintas operaciones sobre un mismo documento de entrada, existen limitaciones asociadas. En primera instancia, el documento resultado debe ajustarse a las normas BSON, las cuales indican que un documento no puede superar los 16MB. Además, MongoDB permite un alojamiento máximo de 100MB de memoria; por lo tanto, en caso de excederse alguna de estas restricciones el sistema responde con error.
%Se tienen dos limitaciones importantes, la primera el tamaño del documento resultado y la segunda es con respecto al uso de memoria del computador en el que se ejecutan las consulta. 
%Con respecto a el tamaño del resultado, MongoDB retorna un cursor o puede almacenar el resultado en una colección. 
%Al realizarse alguna de estas operaciones el documento retornado debe ajustarse a las normas dadas para un documento de tipo BSON. Si por alguna razón el tamaño del documento excede ese limite el sistema responde con error. 
%El segundo aspecto en consideración es el uso de memoria del sistema, por defecto MongoDB ofrece un limite de 100 megabytes, y en caso de que la tubería exceda ese limite se puede producir un error. En caso de ser necesario existe la opción \textit{allowDiskUse} con el cual el sistema utiliza archivos temporales para completar la ejecución, claramente el uso de archivos externos puede traer graves efectos en el desempeño de la base de datos, sin embargo este criterio queda fuera del alcance del articulo.

%Otro elemento de Mongo que es importante considerar es el cursor. Los resultados de una búsqueda en Mongo devuelven un cursor sobre los %datos para que el usuario pueda ver los resultados e iterar sobre los siguientes \cite{cursorMongo}. \textbf{NO SE QUE MÁS AGREGAR, TAL VEZ %ALGUNO ME PUEDA AYUDAR}.
\subsection{Modelaje de los casos de estudio}
Los datos usados en el proyecto, disponibles en el dataset MovieLens 10M DataSet\footnote{https://grouplens.org/datasets/movielens/}, se refieren a las películas y su valoración (rating). Además, se crearon datos de los usuarios asociados a dicha valoración. Se cuenta con  diez mil películas, diez millones de valoraciones y setenta mil usuarios. Cada película puede tener múltiples calificaciones y cada usuario puede calificar distintas películas.

 La primera colección es la colección de películas. Esta contiene el identificador de la película, título y géneros. La segunda es la colección de las valoraciones de las películas. Esta contiene identificador de usuario, identificador de película, valoración y timestamp. Finalmente, la colección de usuarios contiene el identificador de usuario, su nombre y el género. En la figura \ref{fig:pelicula-rating} se puede observar con más detalle el modelo de datos empleado y en la figuras \ref{fig:documento-mongo} y \ref{fig:rating-documento} se puede apreciar como está representado dicho modelo en documentos de MongoDB.

%Es importante mencionar que por el enfoque del trabajo no fue necesaria la limpieza de los datos. Para las pruebas del impacto de índices en el operador lookup se almacenarán ambos componentes en distintas colecciones.

\begin{figure}
\begin{center}
\includegraphics[scale=0.6]{tresColecciones.PNG}
\end{center}
\caption{Modelo de documento de película y de ratings} 
\label{fig:pelicula-rating}
\end{figure}

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{json}
{
	"_id" : "589aa970f2290bf02f601b67",
	"userId" : 1,
	"movieId" : 122,
	"rating" : 5,
	"timestamp" : 838985046
}

\end{minted}
\caption{Representación de documento rating en MongoDB} 
\label{fig:rating-documento}
\end{figure}


Existe además la colección de documentos anidados la cual toma como base el diseño visto en \cite{VeraBoa} donde se considera una relación 1-N, como la que se tiene con películas y valoraciones y se adjunta el bloque de valoraciones que pertenecen a una película en un arreglo de documentos anidados. En las figura \ref{fig:documento-anidado} se pueden observar con más detalle el modelo de datos empleado y en la figura \ref{fig:documento-anidado-Mongo} se aprecia su representación en documento de MongoDB.

\begin{figure}
\begin{center}
\includegraphics[scale=0.8]{anidados.PNG}
\end{center}
\caption{Modelo de documento película con documentos rating anidados} 
\label{fig:documento-anidado}
\end{figure}

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2,
               breaklines]{json}
{
	"_id" : "58a795000b0fa18b936d6279",
	"movieId" : 1,
	"title" : "Toy Story (1995)",
	"genres" : "Adventure|Animation| Children|Comedy|Fantasy",
	"ratings" : [{
			"userId" : 5,
			"movieId" : 1,
			"rating" : 1,
			"timestamp" : 857911264
			},{
			"userId" : 14,
			"movieId" : 1,
			"rating" : 3,
			"timestamp" : 1133572007
			}]
}

\end{minted}
\caption{Representación de documento película con documentos rating anidados en MongoDB} 
\label{fig:documento-anidado-Mongo}
\end{figure}


\subsection{Consultas MongoDB} %Sección de consultas para explicar mongo
A continuación se presentan una serie de consultas que buscan mostrar operaciones básicas de MongoDB, sintaxis y muestra de resultados reales de consultas. La primera consulta, presente en la figura \ref{fig:genre-split}, toma el campo de géneros, originalmente en forma de una hilera, y lo transforma a un arreglo con los diferentes valores. Esta consulta hace uso de la posibilidad de usar funciones de Javascript en MongoDB. En la linea 1 se invoca la función "forEach" que permite realizar una función por cada documento de la colección. En la linea 3 se utiliza la función split de Javascript para separar la hilera en múltiples hileras y estas se guardan en un arreglo. En las lineas 4-7 se ejecuta un update en la colección para cambiar la hilera de géneros por el arreglo de géneros. Los resultados de la consulta se pueden ver en la figura \ref{fig:separacion_genres}.

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=1,
               breaklines]{js}
db.Peliculas.find().forEach(
  function (x) {
    var arr = x.genres.split("|");
    db.Peliculas.update(
      {_id : x._id},
      {$set: {genres : arr}}
    );
  }
)

\end{minted}
\caption{Consulta de separación de géneros} 
\label{fig:genre-split}
\end{figure}



\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{json}
{
	"_id" : "58a78d740b0fa18b936f1d9a",
	"movieId" : 1,
	"title" : "Toy Story (1995)",
	"genres" : [
		"Adeventure" ,
		"Animation" ,
		"Chilfren" ,
		"Comedy" ,
		"Fantasy" 
	]
}

\end{minted}
\caption{Resultados de consulta de separación de géneros} 
\label{fig:separacion_genres}
\end{figure}

La segunda consulta agrupa los identificadores de las películas basado en el puntaje que se le haya otorgado. Esto con la idea de saber cuales películas obtuvieron un puntaje particular. Se puede ver la consulta en la figura \ref{fig:peliculas-por-puntaje}. Las lineas 3-12 determinan como se crean los grupos de identificadores. En la linea 5 se determina que el puntaje sera el identificador del grupo. Esto quiere decir que si dos películas tienen el mismo puntaje ambas pertenecen al mismo grupo. Las linea 6-10 sirven para definir un nuevo valor en el documento llamado "Movies". El resto del código toma el identificador de la película, originalmente un número, lo convierte en una hilera y agrega cada uno, mediante la operación push, al arreglo que se convertirá en el campo "Movies". La linea 15 es necesaria porque al ejecutarse la agrupación se sobrepasan los 100MB permitidos por MongoDB por lo tanto es necesario permitir que se creen archivos temporales para que se pueda llevar a cabo la operación. Parte de los resultados de la consulta se pueden ver en la figura \ref{fig:separacion_por_puntaje}.

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{js}
db.Ratings_Index.aggregate(
  [{
    $group: {
      _id: "$rating",
      Movies: {
        $push: {
          $substr: [
            "$movieId", 0, 10
          ]
        }
      }
    }
  }], {
    allowDiskUse: true
  }
)

\end{minted}
\caption{Consulta de películas separadas por puntaje} 
\label{fig:peliculas-por-puntaje}
\end{figure}


\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{json}
{
	"_id" : 0.5 ,
	"Movies" : [
		"590",
		"1035",
		"2378",	
		"2380",
		"2383",
		"4255",
		"5556"
	]
}
\end{minted}
\caption{Resultados de consulta de agrupación por puntaje} 
\label{fig:separacion_por_puntaje}
\end{figure}

%\section{Ideas}


%\subsection{Operador match, uso de índice}
%Match es un operador de MongoDB que puede ser utilizado dentro de la tubería de agregación y permite reducir la cantidad de documentos a se procesados por las operaciones que le prosiguen en la tubería. Su finalidad es filtrar los documentos de interés excluyendo documentos innecesarios. Las formas alternativas a la utilización de match son crear colecciones de distintos tamaño o no realizar ningún filtro sobre la colección y con ello ejecutar la tubería con todos los documentos. La primera opción no es viable porque se tendrían muchos datos duplicados en la base de datos, se tienen tantas posibilidades de colecciones como documentos tenga la colección a dividir. Por otra parte, la segunda opción conlleva a que si se tienen 10 millones de documentos esa cantidad pasará por cada etapa de la tubería, lo cual trae consigo aumento en los tiempos de ejecución. Por las razones mencionadas el operador match es una opción muy viable al utilizar la tubería de agregación. Sin embargo, su utilización y eficiencia puede depender del uso de un índice sobre el campo de restricción. Por lo tanto, como caso de prueba se hace uso de la colección ratings con índice sobre el campo movieId en una colección y no indexado en una copia de la misma. Posteriormente, se ejecuta el script presente en la figura \ref{fig:consulta-match}, para valores de 1, 100, 1K, 3K, 4K, 5K, 6K, 7K, dicho script es ejecutado en ambas colecciones, indexada y no indexada sobre el campo movieId. Los resultados de dicha ejecución están presentes en las figuras \ref{fig:matchSinEscala}, \ref{fig:matchEscala}.\par 
%\begin{figure}
%    \begin{minted}[frame=single,
%               framesep=3mm,
%               linenos=true,
%               xleftmargin=21pt,
%               tabsize=4]{js}
%    var ini = new Date();
%    db.ratings.aggregate(
%    [{
%        $match:{"movieId":{$lte:tamano}}
%    }]);
%    var fin = new Date();
%    print(fin-ini);
%\end{minted}
%\caption{Match con y sin índice sobre el campo id} 
%\label{fig:consulta-match}
%\end{figure}

%En la figura \ref{fig:matchSinEscala} se observa que para restricciones de pocos elementos, los tiempos de ejecución para una colección sin índice sobre el campo de búsqueda son mucho mayores que los tiempos para la búsqueda con el índice. La razón de esta diferencia consiste en la necesidad de recorrer toda la colección en la búsqueda de documentos debido a que no se cuenta con el índice que ayudaría a detener el proceso de búsqueda. 

%Al contrario, si el campo de búsqueda está indexado, el tiempo de ejecución disminuye por el factor de 2180400. A pesar de esta  diferencia en tiempo de ejecución, se puede ver en la figura \ref{fig:matchSinEscala} que al llegar aproximadamente a los 120000 elementos, el tiempo de ejecución para campo  indexado tiene comportamiento constante (ESTO ES RARO????) , mientras que en la ausencia de índice, el tiempo de ejecución disminuye conforme aumento la cantidad de documentos.  
%\begin{figure}
%\begin{center}
%\includegraphics[scale=0.5]{MatchConSinIndice}
%\end{center}
%\caption{Tiempos de ejecución con y sin índice del operador match} 
%\label{fig:matchSinEscala}
%\end{figure}

%Para mejorar visualización de esta situación, en la figura \ref{fig:matchSinEscala} se presentan los mismos resultados usando  escala logarítmica. Como se puede observar, al llegar a los 3 millones de documentos, se intercambian los papeles y la colección indexada tiene tiempos superiores a la no indexada. La razón es porque cuando se tiene índice se debe pasar por ese espacio de direccionamiento que lleva a los valores. A diferencia de este sin indexar solamente va recorriendo todos los documentos sin saber donde se encuentra. En búsquedas donde se desean pocos datos de una gran cantidad posibles, tener un índice es ideal para evitar recorrer toda la colección. Sin embargo para búsquedas de grandes cantidad de datos sobre colecciones grandes, es mejor evitar el índice. \par 
%\begin{figure}
%\begin{center}
%\includegraphics[scale=0.5]{matchEscalaLogaritmicaG}
%\end{center}
%\caption{Tiempos de ejecución con y sin índice, escala logarítmica} 
%\label{fig:matchEscala}
%\end{figure}
%Es notable que cuando los elementos buscados tienden a la cantidad total de documentos, es innecesario el índice. A pesar de eso, por definición primordial match es un operador para reducir la cantidad de documentos al mínimo. Por lo tanto, lo mencionado conlleva a que al utilizarse match se debería tener un índice asociado. En adición a pesar de que en cierto momento el índice puede ser mejorado por no tenerlo, también es claro la linealidad de tener búsquedas con índice lo cual brinda un gran nivel de confianza sobre las distintas consultas posibles a realizarse. 

Las siguientes dos consultas pertenecen al paradigma de procesamiento de datos llamado Map-Reduce el cual funciona bajo la metodología de asociación llave-valor. Map-Reduce necesita (como mínimo) 3 elementos para su correcto funcionamiento, la función de mapeo, la de reducción y la salida de datos. En la primera consulta, la cual se puede observar en la figura \ref{fig:ConCantidadRatings}, utilizando la colección ratings, se obtienen la cantidad de películas asociadas a cada identificador de película.
\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=1]{js}
db.ratings.mapReduce(
  function(){   
    emit(this.movieId,1);},
  function(key,values){
    return Array.sum(values);},
  {out:"ratingPelicula"}
);
\end{minted}
\caption{Consulta cantidad de ratings por película} 
\label{fig:ConCantidadRatings}
\end{figure}

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{json}
{
	"_id" : 1.0,
	"value" : 26449.0
}
{
	"_id" : 2.0,
	"value" : 12032.0
}
\end{minted}
\caption{Resultado cantidad de ratings por película} 
\label{fig:ResCantidadRatings}
\end{figure}

En las líneas 2,3 se realiza el mapeo, emitiendo la llave-valores que recibe por parámetro la función de reducción en las líneas 4,5. Por ejemplo, existen 100 rating para la película con id=2, la función de mapeo agrupa para esa película un arreglo con 100 unos. La función de reducción al recibir esa llave y el arreglo con 100 unos, realiza la suma del arreglo y retorna el valor, retornando como resultado id=1, valor=100, así para cada una de las películas. Finalmente, en la línea 6, se indica como retornar los resultados, en este caso se guarda el resultado en una colección con nombre ratingPelicula. El resultado de dicha consulta se observa en la figura \ref{fig:ResCantidadRatings}, el cual muestra la cantidad de ratings asociados a la película con id=1 e id=2. 





En la segunda consulta, la cual se puede observar en la figura \ref{fig:ConPorcentajeRating}, se realiza el mismo proceso que el Map-Reduce anterior, en las líneas 2-7 se mapean las llave-valores, la reducción se lleva a cabo en las líneas 8-13. Posteriormente, línea 14 se retorna el valor en línea.
\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{js}
var res=db.ratings.mapReduce(
  function(){
    emit(
      this.movieId,
      this.rating
    );
  },
  function(key,values){
    var sum= Array.sum(values);
    var tamano=values.length;
    var resultado=sum/tamano;
    return resultado;
  },
  {out:{inline:true}}
);
\end{minted}
\caption{Consulta rating promedio por película} 
\label{fig:ConPorcentajeRating}
\end{figure}
El resultado deseado es obtener la calificación promedio que tiene cada película. Por lo tanto, la llave utilizada es el identificador de la película, el valor asociado son las calificaciones (ratings) que recibió dicha película. La función de reducción recibe para cada identificador de película un arreglo con todas las calificaciones que obtuvo. El valor a retornar es la suma de las calificaciones dividido entre la cantidad, operación presente en las líneas 9-12. A diferencia de la consulta Map-Reduce anterior, en la que se guardó el resultado en una colección, en esta consulta el resultado es un documento y se guarda dentro de la variable con nombre res. En la figura \ref{fig:ResPromedioRatings} se presenta el resultado de la consulta, en la cual se tiene el rating promedio de las películas con id=1 e id=2. 

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{json}
{
	"_id" : 1.0,
	"value" : 4.09
}
{
	"_id" : 2.0,
	"value" : 3.31
}
\end{minted}
\caption{Resultados rating promedio por película} 
\label{fig:ResPromedioRatings}
\end{figure}


\section{Desempeño de Consultas}
\subsection{Impacto de índice en el operador lookup}
En esta sección del trabajo se busca analizar la diferencia en el tiempo de ejecución del operador lookup de la función aggregate cuando se utiliza y no se utiliza el índice en el foreign field. Esto con el propósito de determinar qué tan grande es la diferencia utilizando y sin utilizar índices. Además luego de conocer que tan grande es la diferencia determinar si en algún caso seria factible no utilizar un índice. A continuación se describirán los datos a utilizar, las pruebas a realizar y los resultados obtenidos.

Se utilizará una base de datos que contiene siete colecciones. Cinco de Películas donde cada una contiene el id de la película, el nombre y los géneros. La diferencia entre las colecciones es la cantidad de documentos(películas) que contienen. Las colecciones contienen mil, dos mil, tres mil, cuatro mil y cinco mil películas respectivamente. Además la base de datos tiene una colección de ratings que contiene id del usuario, el id de la película, el puntaje y un timestamp de la crítica. Esta última colección contiene diez millones de documentos. Por último existe una colección idéntica a la anterior con la diferencia que esta tiene un índice para el atributo de movieId. Todo esto con base en el modelo de datos descrito en la sección 3.2.

Se formularon 5 pruebas para cada uno de los casos, con y sin índice. Las pruebas se basan en la idea de realizar mediciones de tiempo para la operación join de la colección de películas con la colección de valoraciones (ratings) usando el atributo común que existe entre las colecciones (movieId). Se considera  mil, dos mil, tres mil, cuatro mil y cinco mil documentos de películas y 3081755, 5255829, 6856385, 7841885 y 8461625 de valoraciones, respectivamente como se puede ver en la tabla \ref{table:1}. Se formularon cinco pruebas para cada uno de los casos, con y sin índice, promediando el tiempo de ejecución obtenido en cada prueba para cada caso. Se tomó la decisión de no utilizar un número más grandes de películas debido a muy altos tiempo de ejecución obtenidos para las colecciones mencionadas anteriormente, por ejemplo, de casi cinco horas y media para el caso de cinco mil películas. 
%Además se escoge cinco pruebas porque permite observar la tendencia general de los tiempo sin ser una cantidad exagerada de casos de prueba. 

La  función presente en la figura \ref{fig:consulta-lookupIndices} presenta como se  genera la operación de lookup entre  las películas y sus valoraciones. Las líneas de 3-7 permiten generar el join de las películas con sus valoraciones respectivas.

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{js}
var before = new Date();
var res = db.Peliculas_xk.aggregate
([{$lookup:
  {from: "Ratings_Index",
  localField: "movieId",
  foreignField: "movieId",
  as: "join"}}
]).toArray();
var after = new Date();
var time = after - before;
print(time);
\end{minted}
\caption{Consulta de Lookup sobre moviId} 
\label{fig:consulta-lookupIndices}
\end{figure}

A continuación se presenta una tabla en la que se pueden apreciar los resultados obtenidos en las pruebas. Los números representan la cantidad de segundos necesarios para realizar la consulta con los datos de la columna de películas:

\begin{table}
\begin{center}
\begin{tabular}{ c c c c }
 Películas & Ratings & Con Índice & Sin Índice \\ 
 1.000 & 3.081.755 & 9,0 & 3302,0 \\  
 2.000 & 5.255.829 & 17,0 & 6542,0 \\
 3.000 & 6.856.385 & 22,0 & 9866,0 \\  
 4.000 & 7.841.885 & 25,0 & 13189,0 \\
 5.000 & 8.461.625 & 27,0 & 16599,0
\end{tabular}
\end{center}
\caption{Tiempos de ejecución de lookup con índice y sin índice}
\label{table:1}
\end{table}

Con estos resultados son notorios dos hechos particulares. El primero es que ambos tiempos de ejecución crecen de manera casi lineal. %Esto se puede observar dividiendo los tiempos de ejecución entre la cantidad de películas. Haciendo esto se puede notar que en general se mantiene un valor muy parecido de movieId por segundo para todos los valores de películas. Tanto usando índices como sin usarlos.
La segunda es que la diferencia entre los tiempos de ejecución con y sin índices es notable llegando a tiempo de ejecución superar trescientas veces cuando se ejecutan las consultas sin índice en comparación con la ejecución en la presencia del índice. %Lo más importante de estos números es ver que un lookup sin índice puede, con datos suficientemente grandes, ser altamente ineficiente. Al punto que, dados los resultados obtenidos, podríamos calcular que para hacer un join usando solo una películas se duraría aproximadamente tres segundos. Una cantidad de tiempo intolerable para una aplicación actual. Por esto se podría decir para cualquier aplicación que vaya a utilizar la función de lookup debería utilizar un índice en el atributo usado en el join, a menos de que los datos sean extremadamente reducidos.


\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{graficoTiempos}
\end{center}
\caption{Gráfica de tiempos de ejecución con y sin índice} 
\label{fig:conysin_indice}
\end{figure}

\subsection{Lookup con índice vs documentos anidados}

%hablar de la estrutura de documentos con referencia. despues de Estructura de documentos anidados. Tomando en cuanta las dos diferentes posibilidades de diseño es importarte conocer si alguna de las opciones disponibles presenta ventajas en tiempos de ejecución de consultas.  

El uso del operador lookup y de índice sobre la llave foránea demostró un mayor rendimiento sobre las consultas como se pudo ver en la sección 4.1. Además de ofrecer este operador, MongoDB también proveé otras posibilidades para manipular documentos; una de ellas es documentos anidados. En el siguiente caso de estudio se utilizó el modelo de documentos anidados ofrecido por Mongo para determinar si el rendimiento en consultas es mejor que el dado por el lookup con índice que se estudió anteriormente. 

%Casi que en la conclusión... %Con documentos anidados se busca tener la menor cantidad de referencias externas a una colección con el fin de buscar una mayor ganancia en tiempo de ejecución. 

%En esta sección se va a comparar los tiempos de ejecución de una consulta utilizando el operador lookup contra una consulta sobre documentos anidados. El fin de esta comparación es determinar, según los datos de la base de datos con la que se va a implementar, cual de los dos opciones de trabajar con los datos que ofrece Mongo es mas factible de utilizar, si la idea original de utilizar documentos anidados, o el operador lookup, implementado para cumplir la necesidad de realizar join en diferentes situaciones. Además, de encontrar una diferencia considerable entre las consultas, poder determinar en que casos podría ser recomendable utilizar documentos anidados y en cuales dejarlos en colecciones separadas y utilizar el operador lookup.

Para realizar las comparaciones se utilizará dos bases de datos. La primera base de datos es la misma que es descrita en la sección 4.1; esta contiene colecciones de documentos de películas y sus respectivas valoraciones. La colección valoraciones contiene el atributo movieId indexado. Por otra lado, la segunda base de datos incluye una sola colección de documentos anidados, donde los documentos de películas incluyen un arreglo de documentos de valoraciones correspondientes a cada película.  %A la hora de hacer el análisis de tiempos, las dos bases de datos van a contener los mismos datos con la única diferencia de que van a estar contenidos de forma diferente.

Como se puede ver en la tabla \ref{table:2}, se considera 1,000, 2,500, 4,000, 5,500 y 7,000 de películas y 3,081,755, 6,081,110, 7,841,885, 8,682,809 y 9,177,819 valoraciones, respectivamente. Para cada uno de los conjuntos de datos se realizaron cinco pruebas, tanto como para documentos referenciados como para documentos anidados, promediando el tiempo de ejecución obtenido en cada prueba para cada caso. Para las pruebas con el operador lookup, se implementó la misma consulta realizada para el caso de índice de la subsección anterior. La figura \ref{fig:consulta-anidado} presenta el código la búsqueda en documentos anidados, en la cual aprecia la realización de una consulta donde no se tiene un \say{where} definido. En las lineas 4-8 se deciden que campos se van a mostrar en el resultado

%quitar el where del find
%Se realizaron cinco pruebas para cada uno de los casos, con documentos referenciados y documentos anidados. Estas pruebas se elaboraron para medir los tiempos de ejecución de la operacion lookup sobre documentos referenciados y de la operación find en documentos anidados. 

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=1]{js}
var before = new Date();
var res = db.peliculasX.find
({}, 
  {
    movieId: 1,
    title: 1,
    ratings: 1,
}).toArray();
var after = new Date();
var time = after - before;
print(time);
\end{minted}
\caption{Consulta sobre documentos anidados} 
\label{fig:consulta-anidado}
\end{figure}

En la tabla \ref{table:2} se pueden apreciar los resultados obtenidos en las pruebas. Los números representan la cantidad de segundos que se necesitaron para finalizar la consulta sobre la colección. 

\begin{table}
\begin{center}
\begin{tabular}{ c c c c }
 Películas & Ratings & Lookup indexado & Documentos anidados \\ 
 1.000 & 3.081.755 & 9,0 & 1,1 \\  
 2.500 & 6.081.110 & 20.0 & 2,4 \\
 4.000 & 7.841.885 & 25,0 & 2,8 \\  
 5.500 & 8.682.809 & 29,0 & 3,0 \\
 7.000 & 9.177.819 & 32,0 & 3,2 \\
\end{tabular}
\end{center}
\caption{Tiempos de ejecución de documentos anidados y operador lookup}
\label{table:2}

\end{table}


Con estos resultados se pueden apreciar dos factores particulares. Ambas gráficas crecen de manera casi lineal, como se puede apreciar en e la figura \ref{fig:anidados-lookup}. Por otro lado, la diferencia entre los resultados de tiempos de ejecución demuestra que es mas factible utilizar el modelo de documentos anidados de Mongo, ya que ofrece un menor tiempo de ejecución, reduciendo hasta en 10 veces el tiempo comparado a Lookup. Cabe rescatar que hay un factor a considerar para estos casos, el cual es velocidad de ejecución contra espacio en disco. Esto por que al tener documentos anidados, aunque aumente la velocidad de ejecución, puede darse el caso en donde se dupliquen documentos o información dentro de ellos. Estos factores se deben plantear a la hora de hacer el diseño de la base de datos y tomar una decisión dependiendo de que es más factible según las características de donde van a estar ubicadas las bases de datos.  


\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{anidadosVSlookup}
\end{center}
\caption{Gráfica de tiempos de ejecución} 
\label{fig:anidados-lookup}
\end{figure}

\subsection{Problemas asociados a la unión de más de dos colecciones}
 En MongoDB la estructura de los documentos y las colecciones, tienen que estar diseñados pensando en las consultas que se van a realizar, ya que una mala estructuración  traer consigo tiempos de ejecución extensos. Por dicha razón, en esta sección se presenta un caso en el cual no existe una estructura acorde a la consulta que se desea realizar. \par

La base de datos utilizada para realizar las pruebas de esta sub-sección contiene 3 colecciones, la colección de películas, ratings y la de usuarios. El resultado deseado es una colección en la cual cada documento contiene la información sobre la película con todos sus ratings asociados. Además, cada rating contiene datos sobre la persona que lo realizó. En la figura \ref{fig:consulta-doubleJoin} se presenta la consulta utilizada para obtener dicho resultado. 

\begin{figure}
    \begin{minted}[frame=single,
               framesep=1mm,
               linenos=true,
               xleftmargin=10pt,
               tabsize=2]{js}
db.moviesIndex.aggregate([
{$match: 
  {movieId: {$lte: tamano}}
},
{$lookup: 
  {from: "ratingsIndex",
  localField: "movieId",
  foreignField: "movieId",
  as: "Ratings"}
},
{$project:
  {_id:0,movieId:1,
  title:1,genres:1,
  "Ratings.userId":1,
  "Ratings.rating":1,
  "Ratings.timestamp":1}
},
{$unwind:"$Ratings"},
{$lookup: 
  {from: "usuarios",
  localField: "Ratings.userId",
  foreignField: "userId",
  as: "user"}
},
{$project:
  {movieId:1,title:1,
  genres:1,"Ratings.rating":1,
  "Ratings.timestamp":1,
  "Ratings.userId":"$user"}
},
{$group:
  {_id:"$movieId",
  "title":{$first:"$title"},
  "genres":{$first:"$genres"},
  "ratings":{$push:"$Ratings"}}
}],
{allowDiskUse:true});       
\end{minted}
\caption{Película con ratings y usuarios asociados a cada rating} 
\label{fig:consulta-doubleJoin}
\end{figure}

En un incio, líneas 2-4 reducen la cantidad de documentos para evitar recorrer toda la colección; en las líneas 5-10, se ejecuta el lookup para insertar dentro de cada película sus respectivos ratings. Posteriormente, mediante el operador de proyección se eligen los campos a mostrar y su estructura. En la línea 18, se utiliza el operador unwind, el cual toma de entrada un arreglo y lo separa en nuevos documentos. En el caso de ejemplo, se cuenta con los datos de la película (título, id, géneros) y un arreglo de elementos que se refieren a valoración asociada a dicha película; unwind permite crear un nuevo documento para cada una de estas valoraciones, es decir, por cada película se crean tantos pares película-valoración como valoraciones haya. Posteriormente, en las líneas 19-24 se lleva a cabo el segundo lookup, donde se inserta el usuario dentro de cada valoración. Finalmente, en líneas 31-36 se utiliza el operador group el cual permite agrupar de nuevo todas las películas anteriormente separadas por el operador unwind. Adicionalmente, en la línea 35 se utiliza el operador push que permite recrear  un arreglo parecido como se tuvo al inicio, solamente con un dato más que representa el usuario - emisor de la valoración. Además, como parámetro opcional, línea 37, se permite al sistema hacer uso de disco ya que la operación de agrupación consume todo el espacio de memoria reservado por mongoDB.  \par 

En la figura \ref{fig:doubleJoinTiempos} se muestran los tiempos de ejecución para esta consulta con movieId 20, 40, 80, 200, 400. Se observa que con 400 películas los tiempos superan los 250 segundos, lo cual es un tiempo muy elevado para la cantidad de documentos retornados. Una modificación estructural simple es reemplazar el id de usuario de la colección ratings por los datos del usuario. Gracias a ello se pueden obtener los mismos resultados pero tiempos de ejecución cercanos a los mostrados en al sub-sección 4.6.
Aspectos a tomar en consideración al realizar una consulta como la mostrada anteriormente, la base de datos utilizada tiene en promedio 1500 ratings para cada película, luego del primer lookup líneas 10-15, existen en promedio 7000 películas con 1500 ratings cada una. Posterior al unwind existen 7000*1500 documentos, que luego de insertar el usuario se realiza el proceso inverso, unirlos. Claramente, dicho proceso es altamente consumidor de recursos ya que se crea una gran cantidad de documentos solamente para insertar el usuario y posteriormente volver a su estado anterior. 
\begin{figure}
\begin{center}
\includegraphics[scale=0.5]{DobleLookup}
\end{center}
\caption{Tiempos de ejecución doble lookup} 
\label{fig:doubleJoinTiempos}
\end{figure}




%\subsection{Cambios de Datos}
%Inicialmente se había planteado utilizar tres volúmenes de datos, cada uno de ellos representado por una colección. El primero de un millón de ratings y cuatro mil películas. El segundo de diez millones de ratings y diez mil películas. El tercero de veinte millones de ratings y veintisiete mil películas. El primer inconveniente observado fue que si se utilizaban los sets de diez y veinte millones de manera total las pruebas serían muy extensas. Esto llevó a pensar en modificar el segundo set para generar dos sets de tres y cinco millones. Esta modificación implicaría revisar más a fondo los datos para asegurar que esta modificación no alterara los datos de maneras negativas. Por ejemplo eliminando más ratings ciertas películas que de otras. Dado esto se opto por usar solo el segundo set de datos y utilizar diferentes colecciones para manejar distintos número de películas del join. Permitiendo que las pruebas fueran menos extensas y además permitiendo que los cambios de volumen de datos solo se den en los tamaños de las colecciones.

\section{Conclusión}
MongoDB y los sistemas de bases de datos NoSQL son sistemas altamente usados y reconocidos actualmente. La flexibilidad, facilidad de uso y libertad de esquema hacen que se conviertan en una alternativa atractiva a los sistemas tradicionales de bases de datos. A pesar de eso es necesario hacer hincapié en que una definición lógica y efectiva del modelo de datos sigue siendo importante. Ya que, como se observa en este trabajo, esta puede tener un impacto directo en la efectividad y eficiencia con la que el sistema responde a los objetivos con los que se crea. Por lo tanto se debe hacer uso de un modelo que represente adecuadamente los datos y permita su apropiada manipulación.

Además se observa que el conocimiento de las funcionalidades, operaciones y complejidades de MongoDB es vital para su uso adecuado. Puesto que, como se presenta en el trabajo, la escogencia del cómo se ejecutan las operaciones y como estas aprovechan el modelo de datos definidos es de gran importancia. Ya que una mala escogencia o falta de conocimiento de alternativas podría llevar a un uso ineficiente y un desperdicio de las capacidades de MongoDB.




% conference papers do not normally have an appendix



% use section* for acknowledgment
\ifCLASSOPTIONcompsoc
  % The Computer Society usually uses the plural form
  \section*{Acknowledgments}
\else
  % regular IEEE prefers the singular form
  \section*{Acknowledgment}
\fi


The authors would like to thank...



%\printbibliography

\begin{thebibliography}{1}
  
\bibitem{ObjectId}
MongoDB. (s.f.). \emph{MongoDB Documentation 3.4 - ObjectId} [Online]. Disponible en: https://docs.mongodb.com/manual/reference/method/ObjectId/

\bibitem{AroraAggarwal}
R. Arora y R. Aggarwal. 2013. \emph{Modeling and querying data in mongoDB}. International Journal of Scientific and Engineering Research (IJSER 2013). vol. 4, no. 7, Jul. 2013, pp. 141-144

\bibitem{VeraBoa}
H. Vera, W. Boaventura, M. Holanda, V. Guimaraes, y F. Hondo. (2015). \emph{Data Modeling for NoSQL Document-Oriented Databases}. En CEUR Workshop Proceedings Vol. 1478. pp. 129-135.

\bibitem{Chodorow}
K. Chodorow. \emph{MongoDB: The Difinive Guide}, 2nd ed. O'Reilly Media, 2013.

\bibitem{cursorMongo}
MongoDB. (s.f.). \emph{MongoDB Documentation 3.4 - Cursor} [Online]. Disponible en: https://docs.mongodb.com/v3.4/tutorial/iterate-a-cursor/

\bibitem{indiceMongo}
MongoDB. (s.f.). \emph{MongoDB Documentation 3.4 - Indexes} [Online]. Disponible en:https://docs.mongodb.com/v3.4/indexes/

\bibitem{lookupMongo}
MongoDB. (s.f.). \emph{MongoDB Documentation 3.4 - \$lookup (aggregation)} [Online]. Disponible en: https://docs.mongodb.com/manual/reference/operator/aggregation
/lookup/\#lookup-aggregation 

\bibitem{CRUDMongoMySQL}
C. Octavian, A. Boicea y I. Trifan. (2013). \emph{CRUD Operations in MongoDB}. In Proceedings of the 2013 international Conference on Advanced Computer Science and Electronics Information, Ed. Atlantis Press. pp. 347-350.

\bibitem{aggregationMongo}
MongoDB. (s.f.). \emph{MongoDB Documentation 3.4 - Aggregation} [Online]. Disponible en: https://docs.mongodb.com/manual/aggregation/

\bibitem{MongoDBvsOracle}
A. Boicea, F. Radulescu, y L. I. Agapin, (2012, September). \emph{MongoDB vs Oracle-Database Comparison}. In EIDWT (pp. 330-335).

\bibitem{MongovsCassandravsCouch}
C. Băzăr, y C. S. Iosif, (2014). \emph{The transition from rdbms to nosql. a comparative analysis of three popular non-relational solutions: Cassandra, mongodb and couchbase}. Database Syst J, 5(2), 49-59.

\bibitem{NoSQLDatabases}
A. B. M. Moniruzzaman, y S. A. Hossain, (2013). \emph{Nosql database: New era of databases for big data analytics-classification, characteristics and comparison}. arXiv preprint arXiv:1307.0191.

\bibitem{TypesNoSQLDBs}
A. Nayak, A. Poriya, y D. Poojary, (2013). \emph{Type of NOSQL databases and its comparison with relational databases}. International Journal of Applied Information Systems, 5(4), 16-19.

\bibitem{auto_sharding}
Y. Liu, Y. Wang y Y. Jin. \emph{Research on the improvement of MongoDB Auto-Sharding in cloud environment.} En 7th International Conference on Computer Science and Education (ICCSE), Melbourne, VIC, 2012, pp. 851-854. DOI: 10.1109/ICCSE.2012.6295203

\bibitem{patronDiseno}
R. Copeland. \emph{MongoDB Applied Design Patterns.} Sebastopol, CA: O’Reilly Media, 2013.

\bibitem{embedding}
A. Kanade, A. Gopal y S. Kanade. \emph{A study of normalization and embedding in MongoDB} En 2014 IEEE International Advance Computing Conference (IACC), Gurgaon, 2014, pp. 416-421. DOI: 10.1109/IAdCC.2014.6779360

\bibitem{Bigtable}
F. Chang, J. Dean, S. Ghemawat, W. C. Hsieh, D. A.  Wallach, M. Burrows, T. Chandra, A. Fikes, y R. E. Gruber. \emph{Bigtable: a distributed storage system for structured data} En ACM Transaction of Computer Systems. Vol. 26. Article 4. 2008. 26 pages. DOI: 10.1145/1365815.1365816

\bibitem{MongoInAction}
K. Banker. \emph{MongoDB in Action.} Greenwich, CT: Manning Publications Co., 2011.

\bibitem{Hbase}
G. Lars. \emph{Hbase: The Difinitive Guide.} Sebastopol, CA: O’Reilly Media, 2011.

\bibitem{Cassandra}
A. Lakshman y P. Malik. \emph{Cassandra: a decentralized structured storage system.} En ACM SIGOPS Operating Systems Review. Vol. 44. 2010. pp. 35-40. DOI: 10.1145/1773912.1773922.

\bibitem{esquema}
MongoDB. (s.f.). \emph{NoSQL Databases Explained} [Online]. Disponible en: https://www.mongodb.com/nosql-explained


\end{thebibliography}


\end{document}